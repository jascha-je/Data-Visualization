# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<br><br>
<center><h1>Fahrraddiebst√§hle in Berlin</h1>
<span style="font-size:60px;">üö≤</span>
<br>
<br>
<h2>Berlin z√§hlt zu den Fahrraddiebstahl-Hochburgen Deutschlands</center></h2>
<br>
Laut dem Gesamtverband der Deutschen Versicherungswirtschaft (GDV) werden deutschlandweit die meisten Fahrr√§der in den Stadtstaaten gestohlen. 
F√ºr Berlin ver√∂ffentlicht die Berliner Polizei die gemeldenten Fahrraddiebst√§hle t√§glich. Um die Berliner Fahrraddiebst√§hle zu untersuchen, wurden auf Grundlage dieser Daten verschiedene Visualisierungen erstellt.
<br>
<h2><center></center></h2>
<h3><center>Fahrraddiebst√§hle je 100.000 Einwohner in 2020</center></h3>
<!--<br>
Basis der Ermittlung der risikoreichsten Bundesl√§nder f√ºr Zweiradfahrer ist die offizielle polizeiliche Kriminalstatistik. Ins Verh√§ltnis auf 100.000 Einwohner thront die norddeutsche Hansestadt Bremen mit 876 gestohlenen Fahrr√§dern im Jahr 2020 auf dem ersten Platz. Bereits mit deutlichem Abstand folgen Hamburg mit 789 und Berlin mit 752 Diebstahlf√§llen auf 100.000 Einwohner. Am Ende der Liste befinden sich Baden-W√ºrttemberg (177), Rheinland-Pfalz (151) und das Saarland (104). Deutschlandweit wurden im Jahr 2020 laut der GDV 314 Fahrr√§der pro 100.000 Einwohner gestohlen.
<br>-->
<canvas id="intro-canvas">
</canvas>

<details>
        <summary>Datenquellen</summary>
        <ul>
                <li>GDV/Polizeiliche Kriminalstatistik <a
                                href="https://www.gdv.de/resource/blob/67494/c3d8293893a780fe2264a28a6e941361/download-grafik-deutschlandkarte-data.pdf">https://www.gdv.de/resource/blob/67494/c3d8293893a780fe2264a28a6e941361/download-grafik-deutschlandkarte-data.pdf</a>
                </li>
        </ul>
</details> 
# %%--- [javascript]
# properties:
#   run_on_load: true
#   bottom_hidden: true
#   top_hidden: true
# ---%%
var main_bar_color_1 = '#ef8a62' //orange -> main bar chart color
var main_bar_color_2 = "#a6bddb" //grey -> color of negative bars
var highlight_bars = "#e34a33"//red -> line around bar/season line
var highlight_mean = '#b30000' //dark red -> mean




// load d3.js
await import("https://d3js.org/d3.v7.min.js")
var D3 = d3

// load chart js 
await import("https://cdn.jsdelivr.net/npm/chart.js");
await import("https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.2/dist/chartjs-plugin-annotation.min.js");




let data = await D3.json("https://raw.githubusercontent.com/JJestel/Data-Visualization/main/Sprint_2/data/fahrraddiebstaehle_deutschland_2020.json");

let arrayData = [];
let arrayLabel = [];

for (let key in data) {
  arrayData.push(data[key]);
  arrayLabel.push(key);
}

arrayOfObj = arrayLabel.map(function (d, i) {
  return {
    label: d,
    data: arrayData[i] || 0
  };
});

sortedArrayOfObj = arrayOfObj.slice().sort((a, b) => D3.descending(a.data, b.data))

let newArrayLabel = [];
let newArrayData = [];
let backgroundColor = [];
let germany = 0;

sortedArrayOfObj.forEach(function (d) {

  if (d.label == "Deutschland") {
    germany = d.data;
  } else {
    if (d.label == "Berlin") {
      backgroundColor.push(highlight_bars);
    } else {
      backgroundColor.push('rgba(0, 0, 0, 0)');
    }
    newArrayLabel.push(d.label);
    newArrayData.push(d.data);
  }

});

const options = {
  plugins: {
    annotation: {
      annotations: {
        line1: {
          type: 'line',
          yMin: germany,
          yMax: germany,
          borderColor: highlight_mean,
          borderWidth: 3,
          label: {
            rotation: 'auto',
            content: 'Durchschnitt Deutschland',
            display: true,
            position: "end"
          },
        }
      }
    },
    legend: {
      display: false
    }
  },
  scales: {
    y: {
      title: {
        display: true,
        text: 'Fahrraddiebst√§hle je 100.000 Einwohnende 2020'
      }
    },
    x: {
      title: {
        display: false,
        text: "Bundesland"
      }
    }
  },
};


try {
  Chart.getChart("intro-canvas").destroy()
} catch (error) {

}

const canvas = document.getElementById("intro-canvas");
const myChart = new Chart(canvas.getContext("2d"),
  {
    type: "bar",
    data: {
      labels: newArrayLabel,
      datasets: [
        {
          data: newArrayData,
          label: "Fahrraddiebst√§hle je 100.000 Einwohner 2020",
          backgroundColor: new Array(backgroundColor.length).fill(main_bar_color_1),
          borderColor: backgroundColor,
          borderWidth: 4
        },
      ],
    },
    options: options
  },
);

# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<center><h3> Kennzahlen zu Fahrraddiebst√§hlen in Berlin in 2022</h3></center>
<br>
<br>

  <style>
        table {
                width: 100%;
                table-layout: fixed;
                border: #ffffff solid;
        }

        td {
                border: #ffffff solid;
                text-align: center;
        }

        tr {
                border: #ffffff solid;
        }

        table td:first-child {
                border: #ffffff solid;
        }

        table td:last-child {
                border: #ffffff solid;
        }

        .td-content {
                font-size: 36px !important;
                color: #b30000;
                font-weight: bold;
        }

        .img-filter {
                filter: grayscale(100%);
                height: 110px;
                width: 110px;
        }
</style>


<table cellspacing="0" cellpadding="0">
        <tr>
                <td style="font-size: 20px; color:#b30000"><b>Gesamtschaden</b></td>
                <td style="font-size: 20px; color:#b30000"><b>Gemeldete Diebst√§hle</b></td>
                <td style="font-size: 20px; color:#b30000"><b>&oslash; Schaden pro Diebstahl</b></td>
        </tr>
        <tr>
                <td class="td-content">23,2 Mio.‚Ç¨</td>
                <td class="td-content">22.362</td>
                <td class="td-content">1039‚Ç¨</td>
        </tr>
        <tr>
                <td><img src="https://jjestel.github.io/Data-Visualization/Sprint_2/images/euro.png" class="img-filter">
                </td>
                <td><img src="https://jjestel.github.io/Data-Visualization/Sprint_2/images/brandenburger_tor.png"
                                class="img-filter"></td>
                <td><img src="https://jjestel.github.io/Data-Visualization/Sprint_2/images/bike.png" class="img-filter">
                </td>
        </tr>
</table>
<br>
<br>
<table>
        <tr>
                <td style="font-size: 20px; color:#b30000"><b>Aufkl√§rungsquote</b></td>
                <td style="font-size: 20px; color:#b30000"><b>&oslash; Diebst√§hle pro Tag</b></td>
        </tr>
        <tr>
                <td class="td-content">4,6%</td>
                <td class="td-content">61</td>
        </tr>
        <tr>
                <td><img src="https://jjestel.github.io/Data-Visualization/Sprint_2/images/handcuffs.png" class="img-filter"></td>
                <td><img src="https://jjestel.github.io/Data-Visualization/Sprint_2/images/day.png" class="img-filter">
                </td>
        </tr>
</table>


<details>
    <summary>Datenquellen</summary>
    <ul>
        <li>Fahrraddiebst√§hle <a
                href="https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin">https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin</a>
        </li>
      <li>
        Aufkl√§rungsquote <a href="https://www.berliner-zeitung.de/mensch-metropole/statistik-gestohlener-fahrraeder-in-berlin-li.253061">https://www.berliner-zeitung.de/mensch-metropole/statistik-gestohlener-fahrraeder-in-berlin-li.253061</a>
      </li>
    </ul>
</details>

<details>
        <summary>Bildquellen</summary>
        <ul>
                <li>day by Anton Anuchin from <a href="https://thenounproject.com/browse/icons/term/day/"
                                target="_blank" title="day Icons">Noun Project</a>
                </li>
                <li>Euro by Lnhi from <a href="https://thenounproject.com/browse/icons/term/euro/" target="_blank"
                                title="Euro Icons">Noun Project</a>
                </li>
                <li>Brandenburg Gate by √Ålvaro Y. from <a
                                href="https://thenounproject.com/browse/icons/term/brandenburg-gate/" target="_blank"
                                title="Brandenburg Gate Icons">Noun Project</a>
                </li>
                <li>Bike by Liberus from <a href="https://thenounproject.com/browse/icons/term/bike/" target="_blank"
                                title="Bike Icons">Noun Project</a>
                </li>
                <li>Handcuffs by Fran Couto from <a href="https://thenounproject.com/browse/icons/term/handcuffs/"
                                target="_blank" title="Handcuffs Icons">Noun Project</a>
                </li>
        </ul>
</details>
# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<center><h2>Wo werden die meisten Fahrr√§der in Berlin gestohlen?</h2>

<h3>Und wie gef√§hrdet bist Du?</h3></center>
<br>
Gib dazu eine Adresse ein, an der Du h√§ufig dein Fahrrad abstellst.
Alternativ wird das Institut f√ºr Informatik der FU Berlin genutzt.
<p style="">
<center>
    Standort:  
    <input type="text" id="input-longlat" size="40"
        style="margin-top:1px; border: solid 1px lightgrey; border-radius:4px; height:25px"
        value="Takustra√üe 9, 14195 Berlin">
    <button id="submit-btn" type="button"
        style="border: solid 1px lightgrey; border-radius:4px; height:26px">Suchen</button>
</p>
</center>

<!-- <details>
    <summary>Koordinaten erhalten</summary>
    <ol>
        <li>√ñffnen Sie <a href="https://www.google.de/maps">Google Maps</a>
        </li>
        <li>Mit einem Rechtsklick auf den gew√ºnschten Standort √∂ffnet sich das Kontextmen√º. An oberster Stelle des Men√ºs
            sehen Sie die Koordinaten.
            Mit einem Linksklick darauf werden die Koordinaten zwischengespeichert.
        </li>
        <li>Kopieren Sie die Koordinaten nun in das vorherige Feld und best√§tigen Sie mit Enter.
        </li>
    </ol>
</details> -->
# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<style>
    .tooltip_b {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
    }

    .tooltip_b .tooltiptext {
        visibility: hidden;
        width: 500px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        top: 150%;
        left: 50%;
        margin-left: -250px;
    }

    .tooltip_b .tooltiptext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent transparent black transparent;
    }

    .tooltip_b:hover .tooltiptext {
        visibility: visible;
    }
</style>

<center><h2>Karte Fahrraddiebst√§hle 2022</h2></center>
<br>
Die 2 folgenden Visualisierungen zeigen die Anzahl der Fahrraddiebst√§hle auf Ebene der lebensweltlich orientierten R√§ume
(<div class="tooltip_b">LOR<span class="tooltiptext">Lebensweltlich orientierte R√§ume (LOR) sind eine r√§umliche
        Grundlage f√ºr die Planung, Prognose und Beobachtung demografischer und sozialer Entwicklungen in Berlin. Sie
        lassen sich in 3 Ebenen einteilen: <br>
        542 Planungsr√§ume (PLR)<br>
        143 Bezirksregionen (BZR)<br>
        58 Prognoser√§ume (PRG)
    </span></div>).
<br>
Die aktuelle Visualisierung ist auf Ebene der:

<select id="select_ebene" style="border-color: lightgrey; border-radius:4px">
    <option value="plr">Planungsr√§ume (542)</option>
    <option value="bzr">Bezirksregionen (143)</option>
    <option value="pgr">Prognoser√§ume (58)</option>
</select>
<br>
Eingef√§rbt werden die R√§ume nach der Anzahl der Fahrraddiebst√§hle

<select id="select_measure" style="border-color: lightgrey; border-radius:4px">
    <option value="cases">gesamt</option>
    <option value="cases_per_100k">je 100.000 Einwohnende</option>
</select>

<br>
Die Einteilung der Farben in der Karte wird anhand der folgender
<div class="tooltip_b">Quantilen<span class="tooltiptext">Beispiel: Betrachten wir die Anzahl an Fahrraddiebst√§hlen je
        Planungsraum (543 R√§ume). Das 20 %-Quantil ist dann die Anzahl an Fahrraddiebst√§hlen, sodass 20 % der
        Plangungsr√§ume (ca. 109 R√§ume) weniger Diebst√§hle als die besagte Anzahl aufweisen. <br> </span></div>
berechnet 20/40/60/80/95/100 (%).
<br>
Im <div class="tooltip_b">interaktiven<span class="tooltiptext">
  In der oberen rechten Ecke gibt es Werkzeuge, um mit den Daten zu interagieren.
Mit dem Mauszeiger kannst Du durch Klicken und Ziehen einen ausgew√§hlten Bereich vergr√∂√üern. Ein Doppelklick bringt dich zur√ºck zur urspr√ºnglichen Darstellung.
</span></div>
Balkendiagram darunter sind die gleichen Daten aufsteigend sortiert dargestellt.







<!-- Create an element where the map will take place -->
<div id="container" style="border:solid 0px pink;">

    <svg id="choropleth" width=980 height=830 style="border:solid 0px pink; border-radius:5px"></svg>
    <div id="div-barchart" style="border:solid 0px pink; width:100%"></div>

    <!-- <div style="padding:10px">
        <p style="display: inline-block; ">
            LOR Ebene:
            <select id="select_ebene" style="border-color: lightgrey; border-radius:4px">
                <option value="plr">Planungsr√§ume (542)</option>
                <option value="bzr">Bezirksregionen (143)</option>
                <option value="pgr">Prognoser√§ume (58)</option>
            </select>
        </p>

        <p>
            Fallzahlen:
            <select id="select_measure" style="border-color: lightgrey; border-radius:4px">
                <option value="cases">Absolut</option>
                <option value="cases_per_100k">Je 100.000 Einwohnende</option>
            </select>
        </p>
    </div> -->

    <div id="tooltip"></div>

    <details>
        <summary>Datenquellen</summary>
        <ul>
            <li>Fahrraddiebst√§hle <a
                    href="https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin">https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin</a>
            </li>
            <li>Geodaten <a
                    href="https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin">https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin</a>
            </li>
            <li>Bev√∂lkerung <a
                    href="https://www.statistik-berlin-brandenburg.de/a-i-16-hj">https://www.statistik-berlin-brandenburg.de/a-i-16-hj</a>
            </li>
        </ul>
    </details>

</div>
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
#   bottom_hidden: true
# ---%%
// load all necessary data
const base_path = "https://raw.githubusercontent.com/JJestel/Data-Visualization/main/Sprint_2/data/"

// fahrraddiebstahl f√§lle
var fahrraddiebstahl = await d3.csv(base_path + "fahrraddiebstahl.csv")
// filter nur jahr 2022
fahrraddiebstahl = fahrraddiebstahl.filter(x => x['ANGELEGT_AM'].slice(-4) == "2022")

// kombinierte sozialstruktur/demographie daten je planungsraum
var demographie = await d3.json(base_path + "demographie/demographie_kombiniert_plr.json")

// delikzahlen je bezirksregion
var kriminalitaet = await d3.csv(base_path + "kriminalitaet_2021_fallzahlen_bzr.csv")

// verbindet planungsr√§ume mit bezirksregionen und prognoser√§umen
var lor = await d3.csv(base_path + "LOR_2021.csv")

// 542 planungsr√§ume
var planungsraeume = await d3.json(base_path + "GeoJSON/EPSG_4326/lor_planungsraeume_2021_wgs84.geojson")
// 143 bezirksregionen
var bezirksregionen = await d3.json(base_path + "GeoJSON/EPSG_4326/lor_bezirksregionen_2021_wgs84.geojson")
// 58 prognoseraeume
var prognoseraeume = await d3.json(base_path + "GeoJSON/EPSG_4326/lor_prognoseraeume_2021_wgs84.geojson")
// 12 bezirke
var bezirke = await d3.json(base_path + "GeoJSON/EPSG_4326/bezirksgrenzen.geojson")

var crime_correlation = await d3.json(base_path + "correlation_crime.json")
var index_correlation = await d3.json(base_path + "correlation_index.json")

// import plotly js
try {
  await import("https://cdn.plot.ly/plotly-2.18.0.min.js")
} catch (error) {
  console.log(error)
}




// CELL ***************************************************************************************





const count_per_plr = D3.rollup(fahrraddiebstahl, v => v.length, d => d.LOR)

// create missing plr with 0 cases
for (const el of D3.difference(Array.from(lor, x => x['Planungsraum (Nummer)']), Array.from(count_per_plr.keys()))) {
  count_per_plr.set(el, 0)
}

// add count and count per 100k to lor 
lor.map(el => {
  const plr_id = el['Planungsraum (Nummer)']
  el.cases = count_per_plr.get(plr_id);
  el.population = demographie[plr_id].Gesamt
  el.cases_per_100k = demographie[plr_id].Gesamt == null? null : el.cases / el.population * 100000;
  return el
})

var plr_index = D3.index(lor, v => v['Planungsraum (Nummer)'])
var bzr_index = new Map();
var pgr_index = new Map();

for (const x of plr_index.values()) {
  bzr_id = x["Bezirksregion (Nummer)"]

  let bzr = bzr_index.get(bzr_id)
  if (bzr == undefined) {
    bzr_index.set(bzr_id, {
      "Bezirksregion (Nummer)": bzr_id,
      "Bezirksregion (Name)": x['Bezirksregion (Name)'],
      "cases": x['cases'],
      "cases_per_100k": x['cases_per_100k'],
      "population": x['population'],
    });
  } else {
    bzr['cases'] += x['cases']
    bzr['cases_per_100k'] += x['cases_per_100k']
    bzr['population'] += x['population']
  }

  pgr_id = x["Prognoseraum (Nummer)"]
  let pgr = bzr_index.get(pgr_id)
  if (pgr == undefined) {
    pgr_index.set(pgr_id, {
      "Prognoseraum (Nummer)": pgr_id,
      "Prognoseraum (Name)": x['Prognoseraum (Name)'],
      "cases": x['cases'],
      "cases_per_100k": x['cases_per_100k'],
      "population": x['population'],
    });
  } else {
    pgr['cases'] += x['cases']
    pgr['cases_per_100k'] += x['cases_per_100k']
    pgr['population'] += x['population']
  }
}








// CELL ***************************************************************************************




// helper function to format numbers with points
function formatNumber(num) {
    return num.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.')
}

// Path and projection
const svg = D3.select("#choropleth")
var path = D3.geoPath();
var projection = D3.geoMercator()
  .scale(80000)
  .center([13.424, 52.507])
  .translate([+svg.attr("width") / 2, +svg.attr("height") / 2]);

// function to create choropleth
function render_choropleth(data, {
  targetSVG,
  colorScale,
  fillFeature,
  lorGeoJSON,
  tooltip,
  legend,
} = {}) {

  // ------------------------------------------------------------------------------------
  // Create Tooltip

  const Tooltip = D3.select("#tooltip")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-color", "grey")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")


  // functions that change the tooltip when user hover / move / leave a cell
  const mouseover_lor = function (event, d) {
    D3.select(this)
      .style("stroke-width", 3)
      .style("stroke-opacity", 1)

    Tooltip
      .transition()
      .duration(150)
      .style("opacity", 1)
  }

  const mousemove_lor = function (event, d) {
    Tooltip
      .html(tooltip(d))
      .style("left", (event.pageX + 20) + "px")
      .style("top", (event.pageY) + "px")
  }
  const mouseleave_lor = function (event, d) {
    D3.select(this)
      .style("stroke-width", 1)
      .style("stroke-opacity", 0.5)

    if (event.toElement.tagName != 'circle') {
      Tooltip
        .transition()
        .duration(150)
        .style("opacity", 0);
    }
  }

  // ------------------------------------------------------------------------------------
  // Create Map


  // reset svg element
  targetSVG.node().innerHTML = ''

  // LOR Ebene Zeichen
  targetSVG.append("g")
    .selectAll("path")
    .data(lorGeoJSON.features)
    .join("path")
    .on("mouseover", mouseover_lor)
    .on("mousemove", mousemove_lor)
    .on("mouseleave", mouseleave_lor)
    .attr("d", path.projection(projection))
    .attr("fill", colorScale(0))
    .transition()
    .duration(500)
    .attr("fill", d => colorScale(fillFeature(d)))
    .attr("class", d => 'lor_area')
    .attr("stroke", "black")
    .attr("stroke-opacity", "50%")
  	.attr("data-id", d => d.properties['PLR_ID'] ||  d.properties['BZR_ID'] ||  d.properties['PGR_ID'])

  // Bezirksgrenzen zeichen
  targetSVG.append("g")
    .selectAll("path")
    .data(bezirke.features)
    .join("path")
    .attr("d", path.projection(projection))
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-width", 2)


  // ------------------------------------------------------------------------------------
  // Create Legend

  // legend color rectangles
  const size = 20
  const x_test_start = 820
  const y_start = 64
  
  targetSVG.append("g")
    .selectAll("legend-rect")
    .data(colorScale.range())
    .enter()
    .append("rect")
    .attr("x", x_test_start)
    .attr("y", (d, i) => y_start + i * (size + 5)) // 100 is where the first dot appears. 25 is the distance between dots
    .attr("width", size)
    .attr("height", size)
    .style("fill", d => d)

  // legend text
  targetSVG.append("g").selectAll("legend_text")
    .data([legend.start, ...colorScale.domain()])
    .enter()
    .append("text")
    .attr("x", x_test_start + size * 1.25)
    .attr("y", (d, i) => y_start + i * (size + 5) + (size / 2)) // 100 is where the first dot appears. 25 is the distance between dots
    .style("fill", d => d)
    .text((d, i) => d + " - " + [legend.start, ...colorScale.domain(), legend.end][i + 1])
    .attr("text-anchor", "left")
    .attr("font-size", "12")
    .style("alignment-baseline", "middle")

  // location cirlce 
  targetSVG.append('circle')
      .attr("id", 'location-circle-legend')
      .attr("cx", d => x_test_start + size/2)
      .attr("cy", d => 230)
      .attr('r', 5)
      .attr('stroke', 'black')
      .attr('fill', 'cyan');

    targetSVG.append("text")
    .attr("x", x_test_start + size * 1.25)
    .attr("y", (d, i) => 230)
  	.style("fill", d => d)
    .text((d, i) => "Standort")
    .attr("text-anchor", "left")
    .attr("font-size", "12")
    .style("alignment-baseline", "middle")

  
  // legend title
  const text = targetSVG.append("text")
    .attr("x", x_test_start)
    .attr("y", legend.line1 == ' '? 20 : 10)
    .attr("text-anchor", "left")
	.attr("font-size", "12")
     //.style("alignment-baseline", "middle")
  
  text.append('svg:tspan')
    .attr("dy", '1.2em')
    .attr('x', x_test_start)
    .text(d => legend.line1)
  
  text.append('svg:tspan')
     .attr("dy", '1.2em')
    .attr('x', x_test_start)
    .text(d => legend.line2)

    text.append('svg:tspan')
     .attr("dy", '1.2em')
    .attr('x', x_test_start)
    .text(d => legend.line3)

}






// CELL ***************************************************************************************



// const svg = D3.select("#choropleth")

var current_lng = 0
var current_lat = 0
var current_address = ''

function hightlight_location() {
  let value = document.getElementById('input-longlat').value
  
  let location_el = document.getElementById("location-circle")
  
  if (value == current_address && location_el != null) {
    alert('Der Standort wird bereits angezeigt.')
    return
  }

  current_address = value
  
  if (!value.includes("Berlin")) {
    value += ", Berlin";
  }

  fetch("https://api.opencagedata.com/geocode/v1/json?key=2d21a053360948e9b5c9793d6d069edf&pretty=1&no_annotations=1&q=" + encodeURIComponent(value), {
    method: 'get',
    headers: { 'content-type': 'application/json' }
  })
    .then((response) => response.json())
    .then(function (data) {

      console.log(data["results"].length);
      if (data["results"].length > 0) {
        let city = data["results"][0]["components"]["city"];

        if (city != "Berlin") {
          alert("Die Adresse liegt au√üerhalb von Berlin.");
          return;
        } else {
          let lat = data["results"][0]["geometry"]["lat"];
          let lng = data["results"][0]["geometry"]["lng"];

          if (current_lng == lng && current_lat == lat && location_el != null) {
            return 
          }
          
          value = [lng, lat];
          current_lng = lng
          current_lat = lat
          console.log("lat: " + lat);
          console.log("lng: " + lng);

          // reset old lor in choropleth
          D3.select('.location-lor').attr('stroke', 'black')
            .attr("stroke-width", 1)
            .attr("stroke-opacity", "50%")
            .attr('class', '')

          // delete old location point in choropleth
          svg.select("#location-circle").remove()

          // add new location point in choropleth
          svg.append('circle')
            .attr("id", 'location-circle')
            .attr("cx", d => projection(value)[0])
            .attr("cy", d => projection(value)[1])
            .attr('r', 5)
            .attr('stroke', 'black')
            .attr('fill', 'cyan');

          // find corresponding lor 
          const point = svg.node().createSVGPoint();
          const circle = document.getElementById('location-circle')
          point.x = circle.getAttribute('cx');
          point.y = circle.getAttribute('cy');

          for (const n of D3.selectAll('.lor_area').nodes()) {
            if (n.isPointInFill(point)) {
              const id = n.getAttribute('data-id')
              const value_key = D3.select('#select_ebene').property("value")
              let index = plr_index
              let name_key = 'Planungsraum (Name)'

              if (value_key == 'bzr') {
                index = bzr_index
                name_key = 'Bezirksregion (Name)'
              } else if (value_key == 'pgr') {
                index = pgr_index
                name_key = 'Prognoseraum (Name)'
              }

              D3.select(n).attr('stroke', 'cyan')
                .attr("stroke-width", 2)
                .attr("stroke-opacity", "100%")
                .attr('class', 'location-lor')

              const name = index.get(id)[name_key]
              const graphDiv = document.getElementById('div-barchart')

              const data = graphDiv.data
              const idx = data[0].x.findIndex(x => x == name)
              const color = data[0].y.map(colorScale)
              color[idx] = '#00ffff'

              data[0].marker.color = color

              Plotly.react('div-barchart', data, graphDiv.layout)

              break
            }
          }
        }
      } else {
        alert("Die Adresse konnte leider nicht gefunden werden.");
        return;
      }

    })
    .catch(function (error) {
      console.log(error);
    })
}

D3.select("#submit-btn").on("click", (event) => hightlight_location());





// CELL ***************************************************************************************





function get_tooltip(d, index, name, id, value_key) {
  let tt = d.properties[name] + '<br>'
  if (index.get(d.properties[id])[value_key] == null) {
    tt += 'Keine Daten'
  } else {
    tt += 'Fahrraddiebst√§hle: ' + formatNumber(index.get(d.properties[id])['cases'])
    tt += '<br>Einwohnende: ' + formatNumber(index.get(d.properties[id])['population'])

    const f = D3.format(".1f");
    tt += '<br>Fahrraddiebst√§hle je 100.000 Einwohnende: ' + formatNumber(f(index.get(d.properties[id])['cases_per_100k']).replace(".", ","))

  }
  return tt
}

var colorScale

function update_plots(event, d) {
  const selectedLOR = D3.select('#select_ebene').property("value")
  const value_key = D3.select('#select_measure').property("value")

  // default values
  let lorGeoJSON = planungsraeume
  let index = plr_index
  let id_key = 'PLR_ID'
  let name_key = 'PLR_NAME'
  let lor_name_key = 'Planungsraum (Name)'
  let legendline3 = 'nach Planungsr√§umen'

  switch (selectedLOR) {
    case 'bzr':
      lorGeoJSON = bezirksregionen
      index = bzr_index
      id_key = 'BZR_ID'
      name_key = 'BZR_NAME'
      lor_name_key = 'Bezirksregion (Name)'
      legendline3 = 'nach Bezirksregionen'
      break;
    case 'pgr':
      lorGeoJSON = prognoseraeume
      index = pgr_index
      id_key = 'PGR_ID'
      name_key = 'PGR_NAME'
      lor_name_key = 'Prognoseraum (Name)'
      legendline3 = 'nach Prognoser√§umen'
      break;
  }

  const fillFeature = d => index.get(d.properties[id_key])[value_key] || 0
  const tooltip = d => get_tooltip(d, index, name_key, id_key, value_key)

  // calculate domain for color scale
  let values = lorGeoJSON.features.map(fillFeature)
  let qts = [0.2, 0.4, 0.6, 0.8, 0.95]
  let domain = qts.map(d => Math.round(D3.quantile(values, d)))

  // [6.0, 14.0, 30.0, 62.0, 94]
  colorScale = D3.scaleThreshold()
    .domain(domain)
    .range(['#fef0d9', '#fdd49e', '#fdbb84', '#fc8d59', '#e34a33', '#b30000']);


  render_choropleth(fahrraddiebstahl, {
    targetSVG: D3.select("#choropleth"),
    colorScale: colorScale,
    legend: {
      start: Math.round(D3.min(values)),
      end: Math.round(D3.max(values)),
      line1: value_key == 'cases' ? ' ' : 'Fahrraddiebst√§hle 2022',
      line2: value_key == 'cases' ? 'Fahrraddiebst√§hle 2022' : 'je 100.000 Einwohnende',
      line3: legendline3,
    },
    lorGeoJSON: lorGeoJSON,
    fillFeature: fillFeature,
    tooltip: tooltip,
  })


  // PLOT BARCHART
  const arr = Array.from(index.values()).sort((a, b) => D3.ascending(a[value_key] || 0, b[value_key] || 0))
  
  const data = [
    {
      x: arr.map(x => x[lor_name_key]),
      y: arr.map(x => x[value_key]),
	  text: arr.map(x => x['population']),
      textposition: 'none',
      type: 'bar',
      marker: {
        color: arr.map(x => colorScale(x[value_key])),
      },
      hovertemplate:
            "%{x}<br>" +
            "%{yaxis.title.text}: %{y:,.0f}<br>" +
            "Einwohnende: %{text:,.0f}<br>" +
            "<extra></extra>"
    }
  ]

  const layout = {
    autosize: false,
    width: 950,
    height: 600,
    margin: {
      l: 60,
      r: 10,
      b: 200,
      t: 10,
      pad: 3,
    },
    xaxis: {
      title: {
        text: legendline3.slice(0, -2).replace('nach ', '').replace('√§', 'a'),
        standoff: 10
      },
      tickfont: {
        size: 11,
      }
    },
    yaxis: {
      title: {
        text: 'Fahrraddiebst√§hle' + (value_key == 'cases' ? '' : ' je 100.000 Einwohnende'),
        standoff: 20
      }
    }
  }

  const div = document.getElementById('div-barchart')
  Plotly.newPlot('div-barchart', data, layout);
  
  // const div = document.createElement("div");
  // div.setAttribute("id", "bar-div");
  // Plotly.newPlot(div, data, layout);
  // return div

  // workaround to trigger location hightlight after changing the choropleth 
  setTimeout(() => hightlight_location(), 500);
}


D3.select("#select_ebene").on("change", (event, d) => update_plots(event, d))
D3.select("#select_measure").on("change", (event, d) => update_plots(event, d))

update_plots(null, null)
# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<center><h2>Gibt es saisonalen Trends bei Fahrraddiebst√§hlen?</h2></center>
<br>
In dieser Grafik ist zu sehen, wie viele Fahrr√§der in den Kalenderwochen (KW) des Jahres 2022 gestohlen wurden, wodurch saisonale Trends sichbar werden.
<br><br>
<div>
  <canvas id="canvas-saison"></canvas>
</div>

<details>
    <summary>Datenquellen</summary>
    <ul>
        <li>Fahrraddiebst√§hle <a
                href="https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin">https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin</a>
        </li>
    </ul>
</details>
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
// Make an object with dates as keys
let cases = 0
let dict = {}

for (let obj of fahrraddiebstahl) { //in
    if (!(obj["TATZEIT_ANFANG_DATUM"] in dict)) {
        dict[obj["TATZEIT_ANFANG_DATUM"]] = 1
    }
    dict[obj["TATZEIT_ANFANG_DATUM"]] += 1
}
//console.log(dict)

// Sort keys by date
let sortedEntries = Object.entries(dict).sort(([keyA], [keyB]) => {
    let dateA = new Date(keyA.split('.').reverse().join('-'));
    let dateB = new Date(keyB.split('.').reverse().join('-'));
    return dateA - dateB;
});

let sortedObject = {};

for (let [key, value] of sortedEntries) {
    sortedObject[key] = value;
}
//console.log(sortedObject)

// Drop the first days not included in KW:
let weeks = Object.fromEntries(Object.entries(sortedObject).filter(([key]) => !["01.01.2022", "02.01.2022"].includes(key)))
//console.log(weeks)

// Accumulate data for each week
let keys = Object.keys(weeks)
let accum = {}
const acc = []

for (let i = 0; i < keys.length; i += 7) {
    let key = keys[i];
    accum[key] = weeks[key];

    for (let j = 1; j < 7; j++) {
        if (i + j < keys.length) {
            let nextKey = keys[i + j];
            accum[key] += weeks[nextKey];
        }
    }
    acc[key] = accum[key] // acc[key] -> for forst day of the week, acc[[keys[i+6]]] -> for last day of the week
    //console.log(key)
    //console.log(acc[key])
}
//console.log(acc)

// Calculate weekly mean
let mean = 0
for (let v of Object.values(acc)) {
    mean += v
}
mean = mean / Object.values(acc).length

mean_arr = []
for (let i = 0; i < Object.values(acc).length; i += 1) {
    mean_arr.push(mean)
}

//console.log(mean)

// Make an array with months as Integers
let months = [];

for (key of Object.keys(acc)) {
    let char = Array.from(key)
    let month = char[3] + char[4]
    months.push(parseInt(month))
}
//console.log(months)

// Make an array with months as Stirngs
let months_words = months.map(v => {
    if (v == 1) return "Januar"
    if (v == 2) return "Februar"
    if (v == 3) return "M√§rz"
    if (v == 4) return "April"
    if (v == 5) return "Mai"
    if (v == 6) return "Juni"
    if (v == 7) return "Juli"
    if (v == 8) return "August"
    if (v == 9) return "September"
    if (v == 10) return "Oktober"
    if (v == 11) return "November"
    if (v == 12) return "Dezember"
})

//console.log(months_words)

// Change keys to KW
const acc_clone = structuredClone(acc);

for (let i = 0; i < Object.keys(acc_clone).length; i += 1) {
    newKey = "KW " + String(i)
    acc_clone[newKey] = Object.values(acc_clone)[i]
    delete acc_clone[Object.keys(acc_clone)[0]]
}
//console.log(acc)

//////////////////////////////////////////

// Make an array for plotting: kw; month
var kw_month = Object.keys(acc_clone).map(function (e, i) {
    return e + "; " + months_words[i]
});
//console.log(kw_month)

try {
    Chart.getChart("canvas-saison").destroy()
} catch (error) {

}

const canvas = document.getElementById("canvas-saison");

const myChart = new Chart(canvas.getContext("2d"), {
    //type: "bar",
    data: {
        labels: kw_month,
        datasets: [
            {
                type: "bar",
                data: Object.values(acc),
                backgroundColor: main_bar_color_1,
            },
            {	
                type: "line",
                label: 'Cubic interpolation (monotone)',
                data: Object.values(acc),
                borderColor: highlight_bars,
              	borderWidth: 3,
                fill: false,
                cubicInterpolationMode: 'monotone',
                tension: 0.4
            }
        ]
    },
    options: {
        indexAxis: 'x',
        elements: { bar: { borderWidth: 2 } },
        scales: {
            y: {//min: 0,
                //max: 50,
                title: {
                    display: true,
                    text: 'Fahrraddiebst√§hle'
                }
            },
            x: {
                ticks: {
                    callback: label => 'KW ' + String(label+1)
                }
            },
            xAxis2: {
                type: "category",
                grid: {
                    drawOnChartArea: false, // only want the grid lines for one axis to show up
                },
                ticks: {
                    callback: function (label) {
                        let realLabel = this.getLabelForValue(label)

                        let kw = realLabel.split("; ")[0];
                        let month = realLabel.split("; ")[1];
                        let num = kw.split(" ")[1];
                        if ((parseInt(num)) == 0) {
                            return ""
                        } if (((parseInt(num)) % 4) == 0) {
                            return month;
                        } else {
                            return "";
                        }
                    }
                }
            },
        },

        elements: { point: { radius: 0 }, 
                  bar: {borderRadius: 5}},
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 1 | 2,
        plugins: {
            legend: { display: false },
            title: {
                display: false,
                text: 'Assoziationen'
            },
            annotation: {
                annotations: {
                    line1: {
                        type: 'line',
                        yMin: mean_arr[0],
                        yMax: mean_arr[0],
                        borderColor: highlight_mean,
                        borderWidth: 2,
                        label: {
                            rotation: 'auto',
                            content: 'Durchschnitt',
                            display: true,
                            position: "end"
                        },
                    }
                }
            },
        }
    }
})

# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<br><br>
<center><h2>Besteht ein Zusammenhang mit anderen Ortsmerkmalen?</h2></center>
<br>
Um zu zeigen, welche demographischen und sozialen Aspekte eines LORs mit Anzahl von Fahrraddiebst√§hlen im Zusammenhang stehen, wurde die Produkt-Moment-Korrelation

<div class="tooltip_b">Produkt-Moment-Korrelation<span class="tooltiptext">1 ist die h√∂chste positive Korrelation, was bedeutet, dass die beiden Variablen zusammen auftreten, 
  w√§hrend -1 die h√∂chste negative Korrelation ist, da dort, wo das eine auftritt, das andere einen umgekehrten Trend zeigt. 
  0-Korrelation bedeutet, dass keine lineare Beziehung besteht.<br> </span></div>


 berechnet. Die sich daraus ergebende Zahl gibt an, inwieweit die Anzahl der Fahrraddiebst√§hle pro LOR und ein anderes Merkmal tendenziell einen √§hnlichen Trend aufweisen. 
<br>
# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<div style="height:800px">
	<canvas id="correlation-canvas"></canvas>
</div>
<details>
    <summary>Erl√§uterungen</summary>
* <b>Dynamik-Index</b>: Entwicklung der Auspr√§gungen der drei Dynamik-Indikatoren: Ver√§nderung der Arbeitslosigkeit, Ver√§nderung des Transferbezugs und Ver√§nderung der Kinderarmut im zweij√§hrigen Beobachtungszeitraum, unterteilt in drei Klassen.

<br> ** <b>Anteil Transferbezieher</b>: Anteil der nicht arbeitslosen Empf√§ngerinnen und Empf√§nger von Transferleistungen nach SGB II und SGB XII an den Einwohnerinnen und Einwohnern in Prozent.

<br> *** <b>Status-Index</b>: soziale Lage anhand der Auspr√§gungen der drei Status-Indikatoren: Arbeitslosigkeit, Transferbezug und Kinderarmut, unterteilt in 4 Klassen.

<br> **** <b>Wanderungssaldo</b>: Zuz√ºge minus Fortz√ºge je 100 Einwohnerinnen und Einwohner innerhalb von zwei Jahren in Prozent pro Jahr.
  </details>

<details>
  <summary>Datenquellen</summary>
  	<ul>
            <li>Fahrraddiebst√§hle <a
                    href="https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin">https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin</a>
            </li>
            <li>Bev√∂lkerung <a
                    href="https://www.statistik-berlin-brandenburg.de/a-i-16-hj">https://www.statistik-berlin-brandenburg.de/a-i-16-hj</a>
            </li>
            <li>Index-Indikatoren nach Status und Dynamik und Kontext-Indikatoren <a
                    href="https://www.berlin.de/sen/sbw/stadtdaten/stadtwissen/monitoring-soziale-stadtentwicklung/bericht-2021/tabellen">https://www.berlin.de/sen/sbw/stadtdaten/stadtwissen/monitoring-soziale-stadtentwicklung/bericht-2021/tabellen</a>
            </li>
    </ul>
</details>
# %%--- [javascript]
# properties:
#   run_on_load: true
#   bottom_hidden: true
#   top_hidden: true
# ---%%
let res_unfiltered = index_correlation

let keysToRemove = ["Fahrraddiebst√§hle", "ausl√§nder", "Dynamik-summe", "Status-summe", "EW 31.12.2020",
                   "zD1", "zD3", "zD4", "K06", "K11", "weiblich",
                   "K04", "K05", "K16", "K07", "K17"]

let res = Object.fromEntries(Object.entries(res_unfiltered).filter(([key]) => !keysToRemove.includes(key)))

let names = {K01: "Jugendarbeitslosigkeit",
K02: "Anteil Alleinerziehender Haushalte",
K03: "Altersarmut",
             
//K04: "Kinder und Jugendliche mit Migrationshintergrund",
//K05: "Einwohner:innen mit Migrationshintergrund",
//K16: "Anteil Ausl√§nder:innen",
//K06: "Ver√§nderung Ausl√§nderanteil",
///K07: "Anteil Ausl√§ndischer Transferbezieher an Ausl√§nder:innen",
///K17: "Nicht-EU-Ausl√§nder:innenr an Ausl√§nder:innen",
             
K08: "St√§dtische Wohnungen", //
K14: "Wohnr√§ume", //
K15: "Wohnfl√§che", //
K09: "Anteil einfacher Wohnlage", //Einfache Wohnlage (einschl. L√§rmbelastung)",
K10: "Anteil Wohndauer √ºber 5 Jahre", 
//K11: "Wanderungsvolumen",
K12: "Wanderungssaldo****",
K13: "Wanderungssaldo von Kindern unter 6 Jahren****",

zS1: "Arbeitslosigkeit", //z-Wert 
zS3: "Anteil Transferbezieher**", //"Transferbezieher", //z-Wert 
zS4: "Kinderarmut", //"Transferbezieher unter 15 Jahre", //z-Wert 

//zD1: "z-Wert Ver√§nderung Anteil Arbeitslose",
//zD3: "z-Wert Ver√§nderung Anteil Transferbezieher",
//zD4: "z-Wert Ver√§nderung Anteil Transferbezieher unter 15 Jahren",
               
"Dynamik-Index (standardisierte Dynamik-summe)": "Dynamik-Index*",
"Status-Index (standardisierte Statussumme)": "Status-Index***",
//"EW 31.12.2020": "Gesamte Zahl Einwohner:innen",

unter6: "0-6-j√§hrige",
"6-15": "6-15-j√§hrige",
"15-18": "15-18-j√§hrige",
"18-27": "18-27-j√§hrige",
"27-45": "27-45-j√§hrige",
"45-55": "45-55-j√§hrige",
"55-65": "45-55-j√§hrige",
"65undmehr": "65+j√§hrige",
//weiblich: "Weibliche Einwohnerinnen",
Gesamt: "Gesamte Zahl Einwohner:innen",      
}

let res_keys = Object.keys(res)
let names_keys = Object.keys(names)

let map_names = res_keys.map(v => names_keys.includes(v) ? Object.values(names)[names_keys.indexOf(names_keys.find(k => k == v))] : v)

let map_colors = Object.values(res).map(v => v >= 0 ? main_bar_color_1 : main_bar_color_2)


try {
  Chart.getChart("correlation-canvas").destroy()
} catch (error) {

}

const canvas = document.getElementById("correlation-canvas");
const myChart = new Chart(canvas.getContext("2d"), {
  type: "bar",
  data: {
    labels: map_names,
    datasets: [{data: Object.values(res),
                borderColor: map_colors,
                backgroundColor: map_colors}]},
  options: {
    indexAxis: 'y',
    elements: {bar: {borderWidth: 2}},
    scales: {
      y: {min: 0,
          max: 50,
          title: {display: false,
                  text: 'Variables'}},
      x: {min: -1,
          max: 1,
          title: {display: true,
          text: "Produkt-Moment-Korrelation"}}
    },
    responsive: true,
    maintainAspectRatio: false,
    aspectRatio: 1|1,
    plugins: {
      legend: {display: false},
      title: {display: false,
              text: 'Assoziationen'}
    }}})
# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<br>
<center><h2>Besteht ein Zusammenhang mit andenen Verbrechen?</h2></center>
<br>
Durch die Produkt-Moment-Korrelation kann auch untersucht werden, welche kriminellen Aktivit√§ten mit Fahrraddiebst√§hlen assoziiert sind.
<br>

<div style="height:600px">
	<canvas id="correlation-crime-canvas"></canvas>
</div>
<details>
    <summary>Datenquellen</summary>
    <ul>
        <li>Fahrraddiebst√§hle <a
                href="https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin">https://daten.berlin.de/datensaetze/fahrraddiebstahl-berlin</a>
        </li>
        <li>Kriminalit√§tsatlas <a
                href="https://daten.berlin.de/datensaetze/kriminalit√§tsatlas-berlin">https://daten.berlin.de/datensaetze/kriminalit√§tsatlas-berlin</a>
        </li>
    </ul>
</details>
# %%--- [javascript]
# properties:
#   run_on_load: true
#   bottom_hidden: true
#   top_hidden: true
# ---%%
let res_unfiltered = crime_correlation

let keysToRemove = ["Fahrraddiebstahl", "Fahrraddiebst√§hle"]

let res = Object.fromEntries(Object.entries(res_unfiltered).filter(([key]) => !keysToRemove.includes(key)))

let names = {"Diebstahl-insgesamt": "Diebstahl",
               "Sachbesch√§digung-insgesamt": "Sachbesch√§digung",
               "Straftaten-insgesamt": "Straftaten",
               "K√∂rperverletzungen-insgesamt": "K√∂rperverletzungen",
               "Branddelikte-insgesamt": "Branddelikte",
               "Gef√§hrl und schwere K√∂rperverletzung": "Gef√§hrliche und schwere K√∂rperverletzungen",
               "Stra√üenraub- Handtaschenraub": "Stra√üen- und Handtaschenraub",
               "Diebstahl an/aus Kfz": "Diebstahl an/aus Kraftfahrzeug",
               "Freiheitsberaubung- N√∂tigung- Bedrohung- Nachstellung": "Freiheitsberaubung, N√∂tigung, Bedrohung und Nachstellung",
            }

let res_keys = Object.keys(res)
let names_keys = Object.keys(names)

let map_names = res_keys.map(v => names_keys.includes(v) ? Object.values(names)[names_keys.indexOf(names_keys.find(k => k == v))] : v)

let map_colors = Object.values(res).map(v => v >= 0 ? main_bar_color_1: main_bar_color_2)

try {
  Chart.getChart("correlation-crime-canvas").destroy()
} catch (error) {

}

const canvas = document.getElementById("correlation-crime-canvas");
const myChart = new Chart(canvas.getContext("2d"), {
  type: "bar",
  data: {
    labels: map_names,
    datasets: [{data: Object.values(res),
                borderColor: map_colors,
                backgroundColor: map_colors}]},
  options: {
    indexAxis: 'y',
    elements: {bar: {borderWidth: 2}},
    scales: {
      y: {min: 0,
          max: 50,
          title: {display: false,
                  text: 'Variables'}},
      x: {min: -1,
          max: 1.,
          title: {display: true,
          text: "Produkt-Moment-Korrelation"}}
    },
    responsive: true,
    maintainAspectRatio: false,
    aspectRatio: 1|1,
    plugins: {
      legend: {display: false},
      title: {display: false,
              text: 'Assoziationen'}
    }}})
# %%--- [html]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
<center><h2>Bleib sicher und hab eine gute Fahrt!</h2>
<span style="font-size:60px;">üö≤</span>
</center>